The JiTCDDE module
==================

Introduction
------------

JiTCDDE (just-in-time compilation for delay differential equations) is a standalone Python implementation of the DDE integration method proposed by Thompson and Shampine [TS01]_, which in turn employs the Bogacki–Shampine Runge–Kutta pair [BS89]_.
JiTCDDE is designed in analogy to `JiTCODE <http://github.com/neurophysik/jitcode>`_ (which in turn extends `SciPy’s ODE`_ (`scipy.integrate.ode`)):
It takes an iterable (or generator function) of `SymPy <http://www.sympy.org/>`_ expressions, translates them to C code, compiles them and an integrator wrapped around them on the fly, and allows you to operate this integrator from Python.

This approach has the following advantages

*	**Speed boost through compilation**
	Calculating the derivative and the core operations of the Runge–Kutta integration happen in compiled C code and are thus very fast.
  
*	**Speed boost through symbolic optimisation**
	If your derivative is automatically generated by some routine, you can simplify it symbolically to boost the speed.
	In fact, blatant optimisations such as :math:`y·(x-x)=0` are done on the fly by SymPy.
	This is for example interesting if you want to simulate dynamics on a sparse network, as non-existing links are not taken into account when calculating the derivative when integrating.
	Moreover, multiple delay terms with the same delay can be handled efficiently, requiring only one look-up (see below).

*	**Automatically calculated Lyapunov exponents**
	As the derivative is provided symbolically, SymPy’s automatic derivation routines can be employed to calculate the Jacobian required for the DDE for the tangent vector required for calculating the Lyapunov expontents (see `lyapunov`).

*	**SymPy interface**
	If you are working with SymPy anyway – e.g., to calculate fixed points –, you do not need to bother much with translating your equations.

If compilation fails to work for whatever reason, pure Python functions can be employed as a fallback.

A brief and necessary overview of the mathematics
-------------------------------------------------

This documentation assumes that the delay differential equation (DDE) you want to solve is:

.. math::

	\dot{y} = f(y, y(t-τ_1), y(t-τ_2), …)

The gist of Thompson’s and Shampine’s method [TS01]_ is this:
The differential equation is integrated adaptively with the Bogacki–Shampine pair [BS89]_, like an ODE.
After every successful integration step, the state and derivative of the integration (which is an automatic by-product) are stored.
Whenever the derivative (:math:`f`) is evaluated, the required past states (:math:` y(t-τ_1), y(t-τ_2), …`) are obtained through piece-wise cubic `Hermite interpolation <http://en.wikipedia.org/wiki/Hermite_interpolation>`_ (or in some extreme cases: extrapolation), using previously stored pairs of state and derivative (“anchor”).
Note that unlike for most other DDE software, you have to initiate the past in exactly this way, i.e., you have to give at least two such anchor points.

.. _example:

A quick example
---------------

.. automodule:: mackey-glass	

.. literalinclude:: ../examples/mackey-glass.py
	:linenos:
	:dedent: 1
	:start-after: example-start



Command reference
-----------------

.. automodule:: _jitcdde
	:members:

.. _reference:

References
----------

.. [ST01] L.F. Shampine, S. Thompson: Solving DDEs in Matlab, Applied Numerical Mathematics 37, pp. 441–458 (2001), `10.1016/S0168-9274(00)00055-6 <http://dx.doi.org/10.1016/S0168-9274(00)00055-6>`_.

.. [BS89] P. Bogacki, L.F. Shampine: A 3(2) pair of Runge–Kutta formulas, Applied Mathematics Letters 2, pp. 321–325 (1989), `10.1016/0893-9659(89)90079-7 <http://dx.doi.org/10.1016/0893-9659(89)90079-7>`_.

.. [F82] J. D. Farmer: Chaotic attractors of an infinite-dimensional dynamical system, Physica D 4, pp. 366–393 (1982), `10.1016/0167-2789(82)90042-2 <http://dx.doi.org/10.1016/0167-2789(82)90042-2>`_.

.. [BGGS80]  G. Benettin, L. Galgani, A. Giorgilli, and J.-M. Strelcyn: Lyapunov Characteristic Exponents for smooth dynamical systems and for Hamiltonian systems; A method for computing all of them. Meccanica 15, pp. 9–30 (1980), `10.1007/BF02128236 <http://dx.doi.org/10.1007/BF02128236>`_.

